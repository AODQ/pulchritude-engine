#!/usr/bin/python3

# Parses json generated from json-binding-generator.py and outputs the
#   corresponding bindings for PuleEcs components

# This emits into two separate files:
#   ./generator.inl
#
# You will want to all the function "puleBindGeneratedEcsComponents", passing
#   in ECS system to bind components to.


import argparse, json, os, re

parser = argparse.ArgumentParser("Parses json to ECS component generator")
parser.add_argument("--input", "-i", default="bindings/json/bindings.json")
parser.add_argument("--source-directory", default="")
parser.add_argument("--input-source", default="")
parser.add_argument("--input-ref", "-r", default="bindings/json/bindings.json")
parser.add_argument("--output", "-o", default="bindings/ecs-components")
parser.add_argument("--source", "-s", default=".")
inputArgs = vars(parser.parse_args())

cheader = (
  "// File is automatically generated by\n"
  "//     c-ecs-components-from-json-binding-generator.py\n"
  "// Do not modify directly as any changes will be overwritten\n"
)

def toJoinedStr(thing):
  if (isinstance(thing, str)):
    return thing
  return str.join(' ', thing)

stringTypeNone = 0
stringTypeCStr = 1
stringTypeStringView = 2
stringTypeString = 3

if (not os.path.isdir(f"{inputArgs['output']}")):
  os.makedirs(f"{inputArgs['output']}")

class Out:
  def __init__(self):
    self.outFile = open(f"{inputArgs['output']}/generator.inl", "w")
    self.outFile.write(cheader)
    self.tablevel = 0

  def close(self):
    self.outFile.close()

  def tab(self):
    self.tablevel += 1
  def untab(self):
    self.tablevel = max(0, self.tablevel-1)

  def write(self, outstr):
    for i in range(self.tablevel):
      self.outFile.write("  ")
    self.outFile.write(outstr)
    self.outFile.write("\n")

out = Out()

out.write(f"#include <pulchritude-allocator/allocator.h>")
out.write(f"#include <pulchritude-data-serializer/data-serializer.h>")
out.write(f"#include <pulchritude-ecs/ecs.h>")
out.write(f"#include <pulchritude-imgui/imgui.h>")

out.write("")
for subdir, dirs, files in os.walk(inputArgs['input_source']):
  for filename in files:
    if (not filename.endswith(".h")):
      continue
    filenameprepend = (
      re.sub(inputArgs['source_directory']+"/*", '', inputArgs['input_source'])
    )
    out.write(f"#include \"{filenameprepend}{filename}\"")
out.write("")

symbols = []
labelToTypemap = {}
# load symbols
if True:
  inputJsonFile = open(inputArgs['input'], 'r')
  inputJson = json.load(inputJsonFile)
  inputRefJsonFile = open(inputArgs['input_ref'], 'r')
  inputRefJson = json.load(inputRefJsonFile)
  inputRefJsonFile.close()
  inputJsonFile.close()

  for symbol in inputJson:
    if(symbol['type'] != "using" and symbol['type'] != "struct"):
      continue
    if (symbol['type'] == "using"):
      # look into inputJson and inputRefJson to find the reference datatype,
      for symbolRef in inputJson:
        if (symbolRef['label'] == symbol['typelabel']):
          symbol['fields'] = symbolRef['fields']
      for symbolRef in inputRefJson:
        if (symbolRef['label'] == symbol['typelabel']):
          symbol['fields'] = symbolRef['fields']
      assert('fields' in symbol)
    symbols.append(symbol)

  labelToTypemap = {}
  for field in inputJson:
    labelToTypemap[field['label']] = field['type']
  for field in inputRefJson:
    labelToTypemap[field['label']] = field['type']

out.write('#ifdef __cplusplus\nextern "C" {\n#endif')

def labelEcsStrip(label):
  if (label.endswith("Data")):
    label = label[:-4]
  return label
def isInt(typearr):
  label = toJoinedStr(typearr)
  isIntPattern = re.compile(r"u?int\d+_t")
  return label == "size_t" or isIntPattern.match(label)
def isUnsigned(typearr):
  label = toJoinedStr(typearr)
  isUnsignedPattern = re.compile(r"uint\d+_t")
  return label == "size_t" or isUnsignedPattern.match(label)
def isBool(typearr):
  label = toJoinedStr(typearr)
  return label == "bool"
def isFloating(typearr):
  label = toJoinedStr(typearr)
  return label == "double" or label == "float"
def isStruct(typearr):
  label = toJoinedStr(typearr)
  return label in labelToTypemap and labelToTypemap[label] == 'struct'
def isEnum(typearr):
  label = toJoinedStr(typearr)
  return label in labelToTypemap and labelToTypemap[label] == 'enum'
def isString(typearr):
  if ('*' in typearr and 'char' in typearr):
    return stringTypeCStr
  label = toJoinedStr(typearr)
  if (label == "PuleStringView"):
    return stringTypeStringView
  if (label == "PuleString"):
    return stringTypeString
  return stringTypeNone
def isPointer(typearr):
  return '*' in typearr

def serializeField(field):
  fieldtype = field['type']
  fieldlabel = field['label']
  if (isInt(fieldtype)):
    if (isUnsigned(fieldtype)):
      return f"puleDsCreateU64(data.{fieldlabel})"
    else:
      return f"puleDsCreateI64(data.{fieldlabel})"
  if (isFloating(fieldtype)):
    return f"puleDsCreateF64(data.{fieldlabel})"

  stringType = isString(fieldtype)
  if (stringType == stringTypeCStr):
    return f"puleDsCreateString(puleCStr(data.{fieldlabel}))"
  elif (stringType == stringTypeStringView):
    return f"puleDsCreateString(data.{fieldlabel})"
  elif (stringType == stringTypeString):
    return f"puleDsCreateString(puleStringView(data.{fieldlabel}))"

  if (isEnum(fieldtype)):
    return f"puleDsCreateI64(static_cast<{label}>(data.{fieldlabel}))"

  if (isBool(fieldtype)):
    return f"puleDsCreateBool(data.{fieldlabel})"

  if (isStruct(fieldtype)):
    print(f"struct {fieldtype} unhandled")

  print(f"unhandled ECS component type {field}")
  return None

def componentSymbolSerialize(symbol):
  label = symbol['label']
  out.write(f"static void mod{label}Serialize(")
  out.tab()
  out.write(f"[[maybe_unused]] PuleEcsEntity const entity,")
  out.write(f"void const * const componentData,")
  out.write(f"[[maybe_unused]] PuleDsValue const writeObjectPds,")
  out.write(f"[[maybe_unused]] PuleAllocator const allocator")
  out.untab()
  out.write(f") {{")

  out.tab()
  if (symbol['type'] == "struct" or symbol['type'] == "using"):
    out.write(f"[[maybe_unused]] auto const & data = (")
    out.write(f"  *reinterpret_cast<{label} const *>(componentData)")
    out.write(f");")
    for field in symbol['fields']:
      if (field['meta-type'] != "standard"):
        print(f"unhandled ECS component type {field}")
        continue
      serializedField = serializeField(field)
      if (serializedField == None):
        out.write(f"// unhandled {field}")
        continue
      out.write(f"puleDsAssignObjectMember(")
      out.write(f"  writeObjectPds,")
      out.write(f"  puleCStr(\"{field['label']}\"),")
      out.write(f"  {serializedField}")
      out.write(f");")

  out.untab()
  out.write(f"}}\n")

def deserializeField(field):
  fieldtype = field['type']
  if (isInt(fieldtype)):
    label = toJoinedStr(fieldtype)
    typeconv = {
      "size_t": "USize",
      "uint64_t": "U64", "int64_t": "I64",
      "uint32_t": "U32", "int32_t": "I32",
      "uint16_t": "U16", "int16_t": "I16",
      "uint8_t": "U8", "int8_t": "I8",
    }
    if label not in typeconv:
      print(f"Unhandled integer type: '{label}'")
    return f"puleDsAs{typeconv[label]}"

  if fieldtype[0] == "double":
    return "puleDsAsF64"
  if fieldtype[0] == "float":
    return "puleDsAsF32"

  stringType = isString(fieldtype)
  if (stringType == stringTypeCStr): # TODO need to allocate new strings probly
    return f"puleDsAsString"
  elif (stringType == stringTypeStringView):
    return f"puleDsAsString"
  elif (stringType == stringTypeString):
    return f"puleDsAsString"

  if (isEnum(fieldtype)):
    return f"({fieldtype})puleDsAsI64"

  if (isBool(fieldtype)):
    return f"puleDsAsBool"

  if (isStruct(fieldtype)):
    print(f"struct {fieldtype} unhandled")

  print(f"unhandled ECS component type {field}")
  return None

def componentSymbolDeserialize(symbol):
  label = symbol['label']
  out.write(f"static void mod{label}Deserialize(")
  out.tab()
  out.write(f"PuleEcsWorld const world,")
  out.write(f"PuleEcsEntity const entity,")
  out.write(f"PuleEcsComponent const component,")
  out.write(f"[[maybe_unused]] PuleDsValue const readObjectPds,")
  out.write(f"[[maybe_unused]] PuleAllocator const allocator")
  out.untab()
  out.write(f") {{")
  out.tab()
  out.write(f"{label} data;")
  out.write(f"memset(&data, 0, sizeof(data));")
  for field in symbol['fields']:
    if (field['meta-type'] != "standard"):
      print(f"unhandled ECS component type {field}")
      continue
    deserializedField = deserializeField(field)
    if (deserializedField == None):
      out.write(f"// unhandled {field}")
      continue
    # data.x = puleDsAsF32(puleDsObjectMember(readObjectPds, "x"))
    out.write(f"data.{field['label']} = (")
    out.tab()
    out.write(f"{deserializedField}(")
    out.write(f"  puleDsObjectMember(readObjectPds, \"{field['label']}\")")
    out.write(f")")
    out.untab()
    out.write(f");")
  out.write(f"puleEcsEntityAttachComponent(world, entity, component, &data);")
  out.untab()
  out.write(f"}}\n")

def componentCreate(symbol):
  label = symbol['label']
  out.write(f"PuleEcsComponent mod{label}Create(PuleEcsWorld const world) {{")
  out.tab()
  out.write(f"return puleEcsComponentCreate(")
  out.tab()
  out.write(f"world,")
  out.write(f"PuleEcsComponentCreateInfo {{")
  out.tab()
  out.write(f".label = \"{labelEcsStrip(label)}\",")
  out.write(f".byteLength = sizeof({label}),")
  out.write(f".byteAlignment = sizeof({label}),")
  out.write(
    f".imguiOverviewCallbackOptional = mod{label}ImguiOverviewCallback,"
  )
  out.write(f".imguiEntityCallbackOptional = mod{label}ImguiEntityCallback,")
  out.write(f".serializeComponentCallback = mod{label}Serialize,")
  out.write(f".deserializeComponentCallback = mod{label}Deserialize,")
  out.untab()
  out.write(f"}}")
  out.untab()
  out.write(f");")
  out.untab()
  out.write(f"}}\n")

def componentImguiOverviewCallback(symbol):
  label = symbol['label']
  out.write(f"void mod{label}ImguiOverviewCallback() {{")
  out.tab()
  out.write(f"puleImguiText(\"%zu bytes\", sizeof({label}));")
  out.untab()
  out.write(f"}}\n")

def formatTextField(field):
  fieldtype = toJoinedStr(field['type'])
  fieldlabel = field['label']
  stringType = isString(fieldtype)
  if (isInt(fieldtype)):
    if (isUnsigned(fieldtype)):
      out.write(f"puleImguiText(\"{fieldlabel}: %lu\", data.{fieldlabel});")
    else:
      out.write(f"puleImguiText(\"{fieldlabel}: %lu\", data.{fieldlabel});")
  elif (isFloating(fieldtype)):
    out.write(f"puleImguiText(")
    out.write(f"  \"{fieldlabel}: %f\",")
    out.write(f"  static_cast<double>(data.{fieldlabel})")
    out.write(f");")
  elif (stringType == stringTypeCStr):
    out.write(f"puleImguiText(\"{fieldlabel}: %s\", data.{fieldlabel});")
  elif (stringType == stringTypeStringView):
    out.write(
      f"puleImguiText(\"{fieldlabel}: %s\", data.{fieldlabel}.contents);"
    )
  elif (stringType == stringTypeString):
    out.write(
      f"puleImguiText(\"{fieldlabel}: %s\", data.{fieldlabel}.contents);"
    )
  elif (isEnum(fieldtype)):
    out.write(f"puleImguiText(\"{fieldlabel}: %u\", data.{fieldlabel});")
  elif (isBool(fieldtype)):
    out.write(f"puleImguiText(\"{fieldlabel}: %b\", data.{fieldlabel});")
  elif (isStruct(fieldtype)):
    out.write(f"// struct {fieldtype} unhandled")
  else:
    print(f"unhandled ECS component type {field}")

def componentImguiEntityCallback(symbol):
  label = symbol['label']
  out.write(f"void mod{label}ImguiEntityCallback(")
  out.tab()
  out.write(f"PuleEcsWorld const world,")
  out.write(f"PuleEcsEntity const entity,")
  out.write(f"PuleEcsComponent const component")
  out.untab()
  out.write(f") {{")
  out.tab()
  out.write(f"if (!puleImguiSectionBegin(\"{label}\")) return;")
  out.write(f"[[maybe_unused]] auto const & data = (")
  out.write(f"  *reinterpret_cast<{symbol['label']} const *>(")
  out.write(f"    puleEcsEntityComponentData(world, entity, component)")
  out.write(f"  )")
  out.write(f");")
  for field in symbol['fields']:
    formatTextField(field)
  out.write(f"puleImguiSectionEnd();")
  out.untab()
  out.write(f"}}\n")

# handle serialize, deserialize and create
for symbol in inputJson:
  if (symbol['type'] != "struct" and symbol['type'] != "using"):
    continue
  out.write(f"// --- {symbol['label']} ----")
  componentSymbolSerialize(symbol)
  componentSymbolDeserialize(symbol)
  componentImguiOverviewCallback(symbol)
  componentImguiEntityCallback(symbol)
  componentCreate(symbol)

# register all components
out.write(f"// --- register all components")
out.write(
  f"void modRegisterAllComponents(\n"
  f"  PuleEcsWorld const world,\n"
  f"  void (*registerComponentCallback)(\n"
  f"    PuleStringView const label, PuleEcsComponent const component\n"
  f"  )\n"
  f") {{")
out.tab()
for symbol in inputJson:
  if (symbol['type'] != "struct" and symbol['type'] != "using"):
    continue
  label = symbol['label']
  labelEcs = labelEcsStrip(label)
  out.write(f"{{ // {label}")
  out.tab()
  out.write(f"[[maybe_unused]] auto const id = mod{label}Create(world);")
  out.write(f"if (registerComponentCallback) {{")
  out.tab()
  out.write(f"registerComponentCallback(puleCStr(\"{labelEcs}\"), id);")
  out.untab()
  out.write(f"}}")
  out.untab()
  out.write(f"}}")
out.untab()
out.write(f"}}")

out.write('#ifdef __cplusplus\n} // C\n#endif')
