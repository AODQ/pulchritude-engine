#!/usr/bin/python3

# Parses json generated from json-binding-generator.py and outputs the
#   corresponding lua bindings.
#
# This emits into three separate files:
# ./binding-includes.h
# ./binding-functions.h
# ./binding-states.h
#
# the idea being to include these in your C code to enable Lua integration
# look at library/script/src/setup.cpp for reference
# this file is VERY messy and needs to be reworked, this is mostly me learning
#   how Lua & Lua's C API is supposed to work, from which I can make a nicer
#   script

import argparse
import json
import os
import re

parser = argparse.ArgumentParser("Parses json to lua")
parser.add_argument("--input", "-i", default="bindings/json/bindings.json")
parser.add_argument("--output", "-o", default="bindings/lua")
parser.add_argument("--source", "-s", default=".")
inputArgs = vars(parser.parse_args())

# get typemap
labeltotypemap = {}
with open(inputArgs['input']) as inputJsonFile:
  inputJson = json.load(inputJsonFile)
  for field in inputJson:
    labeltotypemap[field['label']] = field['type']

cheader = (
  "// File is automatically generated by lua-from-json-binding-generator.py\n"
  "// It's to be inserted into a Lua context creation to register all the\n"
  "// valid pulchritude functions/structs\n\n"
)

# --- binding includes
bindingFilename = f"{inputArgs['output']}/binding-includes.h"
os.makedirs(os.path.dirname(bindingFilename), exist_ok=True)
outFile = open(bindingFilename, "w+")
outFile.write(cheader)
includeDir = f"{inputArgs['source']}/library/include/"
print(f"include dir: {includeDir}")
for dirname in next(os.walk(includeDir))[1]:
  packagename = dirname.replace("pulchritude-", "")
  if (packagename == "core"):
    continue
  if (packagename != "asset"):
    macroname = packagename.replace("-", "_").upper()
    outFile.write(f"#if defined(PULCHRITUDE_SCRIPT_BIND_{macroname})\n")
  for subdir, dirs, files in os.walk(f"{includeDir}/{dirname}"):
    for filename in files:
      if (not filename.endswith(".h")):
        continue
      subpackagename = filename.replace(".h", "")
      if (packagename == "asset"):
        macroname = subpackagename.replace("-", "_").upper()
        outFile.write(
          f"#if defined(PULCHRITUDE_SCRIPT_BIND_ASSET_{macroname})\n"
        )
      outFile.write(f"#include \"{dirname}/{filename}\"\n")
      if (packagename == "asset"):
        outFile.write(f"#endif\n\n")
  if (packagename != "asset"):
    outFile.write(f"#endif\n\n")
outFile.close()

# setup for state/function parsing
inputJsonFile = open(inputArgs['input'])
inputJson = json.load(inputJsonFile)

# --- binding functions+structs

def isInt(label):
  isIntPattern = re.compile(r"u?int\d+_t")
  return label == "size_t" or isIntPattern.match(label)
def isBool(label):
  return label == "bool"
def isFloating(label):
  return label == "double" or label == "float"
def isStruct(label):
  return label in labeltotypemap and labeltotypemap[label] == 'struct'
def isEnum(label):
  return label in labeltotypemap and labeltotypemap[label] == 'enum'
def isString(typearr):
  return '*' in typearr and 'char' in typearr
def isPointer(typearr):
  return '*' in typearr
def typeIsSupported(typearr):
  # no pointer-pointer or array support yet
  for t in typearr:
    if ('[' in t or ']' in t):
      return False
  if (len(typearr) == 1 and typearr[0] == "void"):
    return True
  return (
    isInt(typearr[0])      or isBool(typearr[0]) or
    isFloating(typearr[0]) or isStruct(typearr[0])
    or isEnum(typearr[0])
    or isPointer(typearr) or isString(typearr)
  )
def symbolIsSupported(symbol):
  if (symbol['type'] == "function"):
    if (not typeIsSupported(symbol['return-type'])):
      return False
    for param in symbol['parameters']:
      if (
        param['meta-type'] != "standard"
        or not typeIsSupported(param['type'])
      ):
        return False
  elif (symbol['type'] == "struct"):
    for param in symbol['fields']:
      if (
        param['meta-type'] != "standard"
        or not typeIsSupported(param['type'])
      ):
        return False
  return True

def extractTypeToLua(label, param, it):
  import re
  t = param['type']
  if (t[-1] == "const"):
    t = t[:-1]
  out = ""
  typeStr = str.join(' ', t)
  paramError = (
    f"luaArgError(\"{label}\", \"{typeStr}\", \"{param['label']}\")"
  )

  if (len(t) == 1 and isInt(t[0])):
    out += (
      f"  if (!lua_isinteger(state, {it+1})) {{\n"
      f"    {paramError};\n"
      f"  }}\n"
      f"  {t[0]} arg{it} = ({t[0]})(lua_tonumber(state, {it+1}));\n"
    )
  elif (len(t) == 1 and isBool(t[0])):
    out += (
      f"  if (!lua_isboolean(state, {it+1})) {{\n"
      f"    {paramError};\n"
      f"  }}\n"
      f"  {t[0]} arg{it} = ({t[0]})(lua_toboolean(state, {it+1}));\n"
    )
  elif (len(t) == 1 and isFloating(t[0])):
    out += (
      f"  if (!lua_isnumber(state, {it+1})) {{\n"
      f"    {paramError};\n"
      f"  }}\n"
      f"  {t[0]} arg{it} = ({t[0]})(lua_tonumber(state, {it+1}));\n"
    )
  elif (isString(t)):
    out += (
      f"  if (!lua_isstring(state, {it+1})) {{\n"
      f"    {paramError};\n"
      f"  }}\n"
      f"  {typeStr} arg{it} = ({typeStr})(lua_tostring(state, {it+1}));"
    );
  elif (isPointer(t)): # pointer
    out += (
      f"  if (!lua_isuserdata(state, {it+1})) {{\n"
      f"    {paramError};\n"
      f"  }}\n"
      f"  {typeStr} arg{it} = ({typeStr})(lua_touserdata(state, {it+1}));\n"
    )
    pass
    # TODO unhandled
  elif ("Pul" in t[0]): # probably struct
    out += (
      f"  if (!lua_isuserdata(state, {it+1})) {{\n"
      f"    {paramError};\n"
      f"  }}\n"
      f"  {t[0]} arg{it} = *({t[0]} *)(lua_touserdata(state, {it+1}));\n"
    )
    # TODO unhandled
    #out += f"""
    #    {t[0]} * arg{it}Ptr;
    #    if (!lua_isuserdata(state, {it+1})) {{
    #      {paramError}
    #    }}
    #    arg{it}Ptr = ({t[0]} *)(lua_touserdata(state, {it+1}));
    #    if (!arg{it}Ptr) {{
    #      luaUserdataNull(\"{typeStr}\", \"{param['label']}\")
    #    }}
    #    arg{it} = *arg{it}Ptr;
    #"""
  else:
    print(f"unhandled type: {typeStr}")
  return out

def extractFunctionParameter(label, param, it):
  if (param['meta-type'] == 'standard'):
    return extractTypeToLua(label, param, it)

  elif (param['meta-type'] == 'variadic'):
    return ""
  return ""

def extractCopy(fieldType, ftLabel, stackTop):
  fieldTypeStr = str.join(' ', fieldType)
  if (len(fieldType) == 1 and isInt(fieldType[0])):
    return (
      f"  {ftLabel} = lua_tointeger(state, {stackTop});\n"
    )
  elif (len(fieldType) == 1 and isBool(fieldType[0])):
    return (
      f"   {ftLabel} = lua_toboolean(state, {stackTop});\n"
    )
  elif (len(fieldType) == 1 and isFloating(fieldType[0])):
    return (
      f"  {ftLabel} = lua_tonumber(state, {stackTop});\n"
    )
  elif (fieldType[-1] == '*'):
    return f"  // TODO {fieldType}\n"
  elif (isStruct(fieldType[0])):
    return f"  // TODO {fieldType}\n"
  elif (isEnum(fieldType[0])):
    return (
      f" {ftLabel} = ({fieldTypeStr})(lua_tointeger(state, {stackTop}));\n"
    )
  else:
    #print(f"err: unhandled {fieldType} / {ftLabel}")
    return ''

def extractPush(fieldType, ftLabel):
  fieldTypeStr = str.join(' ', fieldType)
  if (len(fieldType) == 1 and isInt(fieldType[0])):
    return f"lua_pushinteger(state, {ftLabel});\n"
  elif (len(fieldType) == 1 and isBool(fieldType[0])):
    return f"lua_pushboolean(state, {ftLabel});\n"
  elif (len(fieldType) == 1 and isFloating(fieldType[0])):
    return f"lua_pushinteger(state, {ftLabel});\n"
  elif (isString(fieldType)):
    return f"lua_pushstring(state, {ftLabel});\n"
  elif (isPointer(fieldType)):
    return f"lua_pushlightuserdata(state, (void *)({ftLabel}));\n"
  elif (isStruct(fieldType[0])):
    return (
      f"{fieldTypeStr} * const rtPtr = (\n"
      f"    ({fieldTypeStr} *)(\n"
      f"      lua_newuserdata(state, sizeof({fieldTypeStr}))\n"
      f"    )\n"
      f"  );\n"
      f"  memcpy(rtPtr, &{ftLabel}, sizeof({fieldTypeStr}));\n"
    )
  elif (isEnum(fieldType[0])):
    return f"lua_pushinteger(state, {ftLabel});\n"
  else:
    #print(f"err: unhandled {fieldType} / {ftLabel}")
    return ''

def extractPop(
  fnLabel, fieldLabel, fieldType, ftLabel, stackIdx, tableIdx
):
  fieldTypeStr = str.join(' ', fieldType)
  pout = (
    f'  {{\n'
    f'  int32_t const oldStackTop = lua_gettop(state);\n'
    f"  lua_rawgeti(state, {stackIdx}, {tableIdx});\n"
    f"  int32_t const newStackTop = oldStackTop+{tableIdx};\n"
    #f'  puleLogDebug("old stack top: %d new stack top: %d", oldStackTop, newStackTop);\n'
  )
  paramError = (
    f'puleLogError('
    f'"Lua error: invalid type: {fieldTypeStr} {fieldLabel} on {fnLabel} call, '
    f'index {tableIdx}"\n'
    f');\n'
    f'lua_pop(state, 1);\n'
    f'dumpLuaStack(state, 1, 0);\n'
  )
  append = f'lua_pop(state, 1);\n'
  if (len(fieldType) == 1 and isInt(fieldType[0])):
    return (
      pout + f"  {ftLabel} = lua_tointeger(state, newStackTop);\n  }}\n" + append
    )
  elif (len(fieldType) == 1 and isBool(fieldType[0])):
    return (
      pout + f"   {ftLabel} = lua_toboolean(state, newStackTop);\n  }}\n" + append
    )
  elif (len(fieldType) == 1 and isFloating(fieldType[0])):
    return (
      pout + f"  {ftLabel} = lua_tonumber(state, newStackTop);\n  }}\n" + append
    )
  elif (isString(fieldType[0])):
    return pout + (
      f"  {ftLabel} = lua_tostring(state, newStackTop);\n  }}\n" + append
    )
  elif (isPointer(fieldType[0])):
    return pout + (
      f"  {ftLabel} = lua_touserdata(state, newStackTop);\n  }}\n" + append
    )
  elif (isStruct(fieldType[0])):
    return pout + (
      f"  if (!lua_isuserdata(state, newStackTop)) {{\n"
      f'    puleLogDebug("attempting to grab stack from %d", newStackTop);\n'
      f"    {paramError};\n"
      f"    return 0;\n"
      f"  }}\n"
      f"  {fieldTypeStr} * userdata{stackIdx} = (\n"
      f"    lua_touserdata(state, newStackTop)\n"
      f"  );\n"
      f"  memcpy(\n"
      f"    &{ftLabel},\n"
      f"    userdata{stackIdx},\n"
      f"    sizeof({fieldTypeStr})\n"
      f"  );\n" + append +
      f"  }}\n"
    )
  elif (isEnum(fieldType[0])):
    return (
      pout + f"  {ftLabel} = lua_tointeger(state, newStackTop);\n  }}\n" + append
    )
  else:
    #print(f"err: unhandled {fieldType} / {ftLabel}")
    return ''


def extractReturnField(rt, fnCall):
  if (len(rt) == 1 and rt[0] == "void"):
    return (
      f"  {fnCall};\n"
      f"  return 0;\n"
    )
  rtStr = str.join(' ', returnType)

  pout = f"  {rtStr} rt = {fnCall};\n"
  pout += f"  {extractPush(rt, 'rt')}"

  return pout + f"  return 1;\n"

outFile = open(f"{inputArgs['output']}/binding-functions.h", "w+")
outFile.write(cheader)
outFile.write(
  "#pragma GCC diagnostic push\n"
  "#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n"
)
for symbol in inputJson:
  modulename = (
    f"PULCHRITUDE_SCRIPT_BIND_"
    f"{symbol['module'].upper().replace('-', '_')}"
  )
  # first just check if we even want bindings for this
  if (not symbolIsSupported(symbol)):
    #print(f"Unsupported symbol: {symbol['label']}");
    continue

  # now proceed to bind
  if (symbol['type'] == "function"):
    label = symbol['label']
    returnType = symbol['return-type']
    pout = f"static int32_t lua{label}(lua_State * state) {{\n"

    validSymbol = True
    paramlist = []
    paramIt = 0
    pout += f"  if (lua_gettop(state) != {len(symbol['parameters'])}) {{\n"
    pout += (
      f"    luaArgCountError(\"{label}\", lua_gettop(state),"
      f" {len(symbol['parameters'])});\n"
    )
    pout += f"  }}\n"
    for param in symbol['parameters']:
      fieldOut = extractFunctionParameter(label, param, paramIt)
      if (fieldOut == ""):
        validSymbol = False
        break
      pout += fieldOut
      paramlist.append(f"arg{paramIt}")
      paramIt += 1

    if (not validSymbol):
      continue

    pout += (
      extractReturnField(returnType, f"{label}({str.join(', ', paramlist)})")
    )
    #outFile.write(f"lua_pushlightuserdata(state, ({returnType})(
    #outFile.write(f"  return 1;\n")
    pout += f"}}\n"
    outFile.write(f"#if defined({modulename})\n")
    outFile.write(pout)
    outFile.write(f"#endif\n\n")
  elif (symbol['type'] == "struct"):
    label = symbol['label']

    validSymbol = True
    paramlist = []
    paramIt = 0

    def parseFields():
      pout = ""
      for field in symbol['fields']:
        if (field['meta-type'] != 'standard'):
          continue # TODO unused
        fieldLabel = field['label']
        fieldType = field['type']
        objLabel = f"objPtr->{fieldLabel}"
        pout += (
          f"    if(strcmp(key, \"{fieldLabel}\") == 0) {{\n"
          f"      {extractPush(fieldType, objLabel)}"
          f"    }}\n"
        )
      return pout

    poutIndex = (
f"""static int32_t lua{label}_index(lua_State * state) {{
  // expecting stack = [self, key]
  {label} * objPtr = ({label} *)(luaL_checkudata(state, 1, \"{label}\"));
  if (!objPtr) {{
    puleLogError("expected {label} but was not found on stack");
    return 0;
  }}

  int type = lua_type(state, 2);
  // don't expect a number (at least for now...)
  if (type == LUA_TSTRING) {{
    char const * key = lua_tostring(state, 2);
{parseFields()}  }} else {{
    puleLogError("unknown type accessing {label}");
    lua_pushnil(state);
  }}
  return 1;
}}
"""
    )

    def parseFields():
      pout = ""
      for field in symbol['fields']:
        if (field['meta-type'] != 'standard'):
          continue # TODO unused
        fieldLabel = field['label']
        fieldType = field['type']
        objLabel = f"objPtr->{fieldLabel}"
        pout += (
          f"    if(strcmp(key, \"{fieldLabel}\") == 0) {{\n"
          f"      {extractCopy(fieldType, objLabel, 3)}\n"
          f"      {extractPush(fieldType, objLabel)}\n"
          f"    }}\n"
        )
      return pout

    poutIndexNew = (
f"""static int32_t lua{label}_newindex(lua_State * state) {{
  // expecting stack = [self, key, value]
  {label} * objPtr = ({label} *)(luaL_checkudata(state, 1, \"{label}\"));
  if (!objPtr) {{
    puleLogError("expected {label} but was not found on stack");
    return 0;
  }}

  int type = lua_type(state, 2);
  // TODO verify value is correct type
  // don't expect a number (at least for now...)
  if (type == LUA_TSTRING) {{
    char const * key = lua_tostring(state, 2);
{parseFields()}  }} else {{
    puleLogError("unknown type accessing {label}");
    lua_pushnil(state);
  }}
  return 1;
}}
"""
    )

    def parseFields():
      pout = ""
      for fieldIt, field in enumerate(symbol['fields']):
        if (field['meta-type'] != 'standard'):
          continue # TODO unused
        fieldLabel = field['label']
        fieldType = field['type']
        objLabel = f"objPtr->{fieldLabel}"
        pout += (
          extractPop(
            fnLabel = symbol['label'],
            fieldLabel=fieldLabel,
            fieldType=fieldType,
            ftLabel=objLabel,
            stackIdx=2,
            tableIdx=fieldIt+1
          )
        )
      return pout

    poutNew = (
f"""static int32_t lua{label}_new(lua_State * state) {{
  luaL_checktype(state, 2, LUA_TTABLE);
  // create temporary pointer to not fiddle with the lua stack
  {label} * objPtr = ({label} *)(malloc(sizeof({label})));
{parseFields()}  lua_settop(state, 0);
  {label} * obj = ({label} *)(lua_newuserdata(state, sizeof({label})));
  luaL_getmetatable(state, "{label}");
  lua_setmetatable(state, 1);

  memcpy(obj, objPtr, sizeof({label}));
  free(objPtr);

  return 1;
}}
"""
    )

    poutMetatable = (
f"""static int32_t lua{label}_register(lua_State * state) {{
  lua_settop(state, 0);
  if (luaL_newmetatable(state, \"{label}\")) {{
    static struct luaL_Reg metamethods[] = {{
      {{"__index", lua{label}_index}},
      {{"__newindex", lua{label}_newindex}},
      {{NULL, NULL}},
    }};
    luaL_setfuncs(state, metamethods, 0);
    lua_pop(state, 1);
  }}
  static struct luaL_Reg fns[] = {{
    {{\"new\", lua{label}_new}},
    {{NULL, NULL}},
  }};
  luaL_newlib(state, fns);
  lua_setglobal(state, "{label}");
  lua_settop(state, 0);
  return 1;
}}"""
    )
    outFile.write(f"#if defined({modulename})\n")
    outFile.write(f"{poutNew}\n")
    outFile.write(f"{poutIndex}\n")
    outFile.write(f"{poutIndexNew}\n")
    outFile.write(f"{poutMetatable}\n")
    outFile.write(f"#endif\n\n")
outFile.close()

# --- binding states
outFile = open(f"{inputArgs['output']}/binding-states.h", "w+")
outFile.write(cheader)
outFile.write("#define luaPushFunc(label)                         \\\n")
outFile.write('  puleLogDebug("Registering function %s", #label); \\\n')
outFile.write("  lua_pushcfunction(state, lua ## label);          \\\n")
outFile.write("  lua_setglobal(state, #label);                    \\\n\n")

def enumPushValueToGlobal(value):
  return (
    f"lua_pushliteral(state, \"{value['label']}\");\n"
    f"lua_pushnumber(state, {value['value']});\n"
    f"lua_settop(state, 0);\n"
  )

for symbol in inputJson:
  modulename = (
    f"PULCHRITUDE_SCRIPT_BIND_"
    f"{symbol['module'].upper().replace('-', '_')}"
  )
  if (not symbolIsSupported(symbol)):
    continue
  if (symbol['type'] == "function"):
    outFile.write(f"#if defined({modulename})\n")
    outFile.write(f"luaPushFunc({symbol['label']});\n")
    outFile.write(f"#endif\n")
  elif (symbol['type'] == "struct"):
    outFile.write(f"#if defined({modulename})\n")
    outFile.write(f"lua{symbol['label']}_register(state);\n")
    outFile.write(f"#endif\n")
  elif (symbol['type'] == "enum"):
    outFile.write(f"#if defined({modulename})\n")
    for value in symbol['values']:
      if ('MaxEnum' in value['label']): # not necessary for lua
        continue
      outFile.write(enumPushValueToGlobal(value))
    outFile.write(f"#endif\n")
outFile.write("#undef luaPushFunc\n")
outFile.write("#pragma GCC diagnostic pop")
outFile.close()

inputJsonFile.close()
